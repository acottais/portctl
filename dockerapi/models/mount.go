// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Mount mount
// swagger:model Mount
type Mount struct {

	// bind options
	BindOptions *MountBindOptions `json:"BindOptions,omitempty"`

	// The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.
	Consistency string `json:"Consistency,omitempty"`

	// Whether the mount should be read-only.
	ReadOnly bool `json:"ReadOnly,omitempty"`

	// Mount source (e.g. a volume name, a host path).
	Source string `json:"Source,omitempty"`

	// Container path.
	Target string `json:"Target,omitempty"`

	// tmpfs options
	TmpfsOptions *MountTmpfsOptions `json:"TmpfsOptions,omitempty"`

	// The mount type. Available types:
	//
	// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
	// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
	// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
	// - `npipe` Mounts a named pipe from the host into the container. Must exist prior to creating the container.
	//
	// Enum: [bind volume tmpfs npipe]
	Type string `json:"Type,omitempty"`

	// volume options
	VolumeOptions *MountVolumeOptions `json:"VolumeOptions,omitempty"`
}

// Validate validates this mount
func (m *Mount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBindOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTmpfsOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Mount) validateBindOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.BindOptions) { // not required
		return nil
	}

	if m.BindOptions != nil {
		if err := m.BindOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("BindOptions")
			}
			return err
		}
	}

	return nil
}

func (m *Mount) validateTmpfsOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.TmpfsOptions) { // not required
		return nil
	}

	if m.TmpfsOptions != nil {
		if err := m.TmpfsOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TmpfsOptions")
			}
			return err
		}
	}

	return nil
}

var mountTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bind","volume","tmpfs","npipe"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		mountTypeTypePropEnum = append(mountTypeTypePropEnum, v)
	}
}

const (

	// MountTypeBind captures enum value "bind"
	MountTypeBind string = "bind"

	// MountTypeVolume captures enum value "volume"
	MountTypeVolume string = "volume"

	// MountTypeTmpfs captures enum value "tmpfs"
	MountTypeTmpfs string = "tmpfs"

	// MountTypeNpipe captures enum value "npipe"
	MountTypeNpipe string = "npipe"
)

// prop value enum
func (m *Mount) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, mountTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Mount) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("Type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Mount) validateVolumeOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.VolumeOptions) { // not required
		return nil
	}

	if m.VolumeOptions != nil {
		if err := m.VolumeOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("VolumeOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Mount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Mount) UnmarshalBinary(b []byte) error {
	var res Mount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MountBindOptions Optional configuration for the `bind` type.
// swagger:model MountBindOptions
type MountBindOptions struct {

	// Disable recursive bind mount.
	NonRecursive *bool `json:"NonRecursive,omitempty"`

	// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
	// Enum: [private rprivate shared rshared slave rslave]
	Propagation string `json:"Propagation,omitempty"`
}

// Validate validates this mount bind options
func (m *MountBindOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePropagation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var mountBindOptionsTypePropagationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["private","rprivate","shared","rshared","slave","rslave"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		mountBindOptionsTypePropagationPropEnum = append(mountBindOptionsTypePropagationPropEnum, v)
	}
}

const (

	// MountBindOptionsPropagationPrivate captures enum value "private"
	MountBindOptionsPropagationPrivate string = "private"

	// MountBindOptionsPropagationRprivate captures enum value "rprivate"
	MountBindOptionsPropagationRprivate string = "rprivate"

	// MountBindOptionsPropagationShared captures enum value "shared"
	MountBindOptionsPropagationShared string = "shared"

	// MountBindOptionsPropagationRshared captures enum value "rshared"
	MountBindOptionsPropagationRshared string = "rshared"

	// MountBindOptionsPropagationSLAVE captures enum value "slave"
	MountBindOptionsPropagationSLAVE string = "slave"

	// MountBindOptionsPropagationRslave captures enum value "rslave"
	MountBindOptionsPropagationRslave string = "rslave"
)

// prop value enum
func (m *MountBindOptions) validatePropagationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, mountBindOptionsTypePropagationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MountBindOptions) validatePropagation(formats strfmt.Registry) error {

	if swag.IsZero(m.Propagation) { // not required
		return nil
	}

	// value enum
	if err := m.validatePropagationEnum("BindOptions"+"."+"Propagation", "body", m.Propagation); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MountBindOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MountBindOptions) UnmarshalBinary(b []byte) error {
	var res MountBindOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MountTmpfsOptions Optional configuration for the `tmpfs` type.
// swagger:model MountTmpfsOptions
type MountTmpfsOptions struct {

	// The permission mode for the tmpfs mount in an integer.
	Mode int64 `json:"Mode,omitempty"`

	// The size for the tmpfs mount in bytes.
	SizeBytes int64 `json:"SizeBytes,omitempty"`
}

// Validate validates this mount tmpfs options
func (m *MountTmpfsOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MountTmpfsOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MountTmpfsOptions) UnmarshalBinary(b []byte) error {
	var res MountTmpfsOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MountVolumeOptions Optional configuration for the `volume` type.
// swagger:model MountVolumeOptions
type MountVolumeOptions struct {

	// driver config
	DriverConfig *MountVolumeOptionsDriverConfig `json:"DriverConfig,omitempty"`

	// User-defined key/value metadata.
	Labels map[string]string `json:"Labels,omitempty"`

	// Populate volume with data from the target.
	NoCopy *bool `json:"NoCopy,omitempty"`
}

// Validate validates this mount volume options
func (m *MountVolumeOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDriverConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MountVolumeOptions) validateDriverConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.DriverConfig) { // not required
		return nil
	}

	if m.DriverConfig != nil {
		if err := m.DriverConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("VolumeOptions" + "." + "DriverConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MountVolumeOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MountVolumeOptions) UnmarshalBinary(b []byte) error {
	var res MountVolumeOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MountVolumeOptionsDriverConfig Map of driver specific options
// swagger:model MountVolumeOptionsDriverConfig
type MountVolumeOptionsDriverConfig struct {

	// Name of the driver to use to create the volume.
	Name string `json:"Name,omitempty"`

	// key/value map of driver specific options.
	Options map[string]string `json:"Options,omitempty"`
}

// Validate validates this mount volume options driver config
func (m *MountVolumeOptionsDriverConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MountVolumeOptionsDriverConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MountVolumeOptionsDriverConfig) UnmarshalBinary(b []byte) error {
	var res MountVolumeOptionsDriverConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
