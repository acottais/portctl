// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HostConfig Container configuration that depends on the host we are running on
// swagger:model HostConfig
type HostConfig struct {
	Resources

	// Automatically remove the container when the container's process exits. This has no effect if `RestartPolicy` is set.
	AutoRemove bool `json:"AutoRemove,omitempty"`

	// A list of volume bindings for this container. Each volume binding is a string in one of these forms:
	//
	// - `host-src:container-dest` to bind-mount a host path into the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
	// - `host-src:container-dest:ro` to make the bind mount read-only inside the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
	// - `volume-name:container-dest` to bind-mount a volume managed by a volume driver into the container. `container-dest` must be an _absolute_ path.
	// - `volume-name:container-dest:ro` to mount the volume read-only inside the container.  `container-dest` must be an _absolute_ path.
	//
	Binds []string `json:"Binds"`

	// A list of kernel capabilities to add to the container. Conflicts with option 'Capabilities'
	CapAdd []string `json:"CapAdd"`

	// A list of kernel capabilities to drop from the container. Conflicts with option 'Capabilities'
	CapDrop []string `json:"CapDrop"`

	// A list of kernel capabilities to be available for container (this overrides the default set).
	//
	// Conflicts with options 'CapAdd' and 'CapDrop'"
	//
	Capabilities []string `json:"Capabilities"`

	// Cgroup to use for the container.
	Cgroup string `json:"Cgroup,omitempty"`

	// Initial console size, as an `[height, width]` array. (Windows only)
	// Max Items: 2
	// Min Items: 2
	ConsoleSize []*int64 `json:"ConsoleSize"`

	// Path to a file where the container ID is written
	ContainerIDFile string `json:"ContainerIDFile,omitempty"`

	// A list of DNS servers for the container to use.
	DNS []string `json:"Dns"`

	// A list of DNS options.
	DNSOptions []string `json:"DnsOptions"`

	// A list of DNS search domains.
	DNSSearch []string `json:"DnsSearch"`

	// A list of hostnames/IP mappings to add to the container's `/etc/hosts` file. Specified in the form `["hostname:IP"]`.
	//
	ExtraHosts []string `json:"ExtraHosts"`

	// A list of additional groups that the container process will run as.
	GroupAdd []string `json:"GroupAdd"`

	// IPC sharing mode for the container. Possible values are:
	//
	// - `"none"`: own private IPC namespace, with /dev/shm not mounted
	// - `"private"`: own private IPC namespace
	// - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
	// - `"container:<name|id>"`: join another (shareable) container's IPC namespace
	// - `"host"`: use the host system's IPC namespace
	//
	// If not specified, daemon default is used, which can either be `"private"`
	// or `"shareable"`, depending on daemon version and configuration.
	//
	IpcMode string `json:"IpcMode,omitempty"`

	// Isolation technology of the container. (Windows only)
	// Enum: [default process hyperv]
	Isolation string `json:"Isolation,omitempty"`

	// A list of links for the container in the form `container_name:alias`.
	Links []string `json:"Links"`

	// log config
	LogConfig *HostConfigAO1LogConfig `json:"LogConfig,omitempty"`

	// The list of paths to be masked inside the container (this overrides the default set of paths)
	MaskedPaths []string `json:"MaskedPaths"`

	// Specification for mounts to be added to the container.
	Mounts []*Mount `json:"Mounts"`

	// Network mode to use for this container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.
	NetworkMode string `json:"NetworkMode,omitempty"`

	// An integer value containing the score given to the container in order to tune OOM killer preferences.
	OomScoreAdj int64 `json:"OomScoreAdj,omitempty"`

	// Set the PID (Process) Namespace mode for the container. It can be either:
	//
	// - `"container:<name|id>"`: joins another container's PID namespace
	// - `"host"`: use the host's PID namespace inside the container
	//
	PidMode string `json:"PidMode,omitempty"`

	// port bindings
	PortBindings PortMap `json:"PortBindings,omitempty"`

	// Gives the container full access to the host.
	Privileged bool `json:"Privileged,omitempty"`

	// Allocates an ephemeral host port for all of a container's
	// exposed ports.
	//
	// Ports are de-allocated when the container stops and allocated when the container starts.
	// The allocated port might be changed when restarting the container.
	//
	// The port is selected from the ephemeral port range that depends on the kernel.
	// For example, on Linux the range is defined by `/proc/sys/net/ipv4/ip_local_port_range`.
	//
	PublishAllPorts bool `json:"PublishAllPorts,omitempty"`

	// The list of paths to be set as read-only inside the container (this overrides the default set of paths)
	ReadonlyPaths []string `json:"ReadonlyPaths"`

	// Mount the container's root filesystem as read only.
	ReadonlyRootfs bool `json:"ReadonlyRootfs,omitempty"`

	// restart policy
	RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`

	// Runtime to use with this container.
	Runtime string `json:"Runtime,omitempty"`

	// A list of string values to customize labels for MLS systems, such as SELinux.
	SecurityOpt []string `json:"SecurityOpt"`

	// Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.
	// Minimum: 0
	ShmSize *int64 `json:"ShmSize,omitempty"`

	// Storage driver options for this container, in the form `{"size": "120G"}`.
	//
	StorageOpt map[string]string `json:"StorageOpt,omitempty"`

	// A list of kernel parameters (sysctls) to set in the container. For example: `{"net.ipv4.ip_forward": "1"}`
	//
	Sysctls map[string]string `json:"Sysctls,omitempty"`

	// A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: `{ "/run": "rw,noexec,nosuid,size=65536k" }`.
	//
	Tmpfs map[string]string `json:"Tmpfs,omitempty"`

	// UTS namespace to use for the container.
	UTSMode string `json:"UTSMode,omitempty"`

	// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
	UsernsMode string `json:"UsernsMode,omitempty"`

	// Driver that this container uses to mount volumes.
	VolumeDriver string `json:"VolumeDriver,omitempty"`

	// A list of volumes to inherit from another container, specified in the form `<container name>[:<ro|rw>]`.
	VolumesFrom []string `json:"VolumesFrom"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *HostConfig) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 Resources
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.Resources = aO0

	// AO1
	var dataAO1 struct {
		AutoRemove bool `json:"AutoRemove,omitempty"`

		Binds []string `json:"Binds"`

		CapAdd []string `json:"CapAdd"`

		CapDrop []string `json:"CapDrop"`

		Capabilities []string `json:"Capabilities"`

		Cgroup string `json:"Cgroup,omitempty"`

		ConsoleSize []*int64 `json:"ConsoleSize"`

		ContainerIDFile string `json:"ContainerIDFile,omitempty"`

		DNS []string `json:"Dns"`

		DNSOptions []string `json:"DnsOptions"`

		DNSSearch []string `json:"DnsSearch"`

		ExtraHosts []string `json:"ExtraHosts"`

		GroupAdd []string `json:"GroupAdd"`

		IpcMode string `json:"IpcMode,omitempty"`

		Isolation string `json:"Isolation,omitempty"`

		Links []string `json:"Links"`

		LogConfig *HostConfigAO1LogConfig `json:"LogConfig,omitempty"`

		MaskedPaths []string `json:"MaskedPaths"`

		Mounts []*Mount `json:"Mounts"`

		NetworkMode string `json:"NetworkMode,omitempty"`

		OomScoreAdj int64 `json:"OomScoreAdj,omitempty"`

		PidMode string `json:"PidMode,omitempty"`

		PortBindings PortMap `json:"PortBindings,omitempty"`

		Privileged bool `json:"Privileged,omitempty"`

		PublishAllPorts bool `json:"PublishAllPorts,omitempty"`

		ReadonlyPaths []string `json:"ReadonlyPaths"`

		ReadonlyRootfs bool `json:"ReadonlyRootfs,omitempty"`

		RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`

		Runtime string `json:"Runtime,omitempty"`

		SecurityOpt []string `json:"SecurityOpt"`

		ShmSize *int64 `json:"ShmSize,omitempty"`

		StorageOpt map[string]string `json:"StorageOpt,omitempty"`

		Sysctls map[string]string `json:"Sysctls,omitempty"`

		Tmpfs map[string]string `json:"Tmpfs,omitempty"`

		UTSMode string `json:"UTSMode,omitempty"`

		UsernsMode string `json:"UsernsMode,omitempty"`

		VolumeDriver string `json:"VolumeDriver,omitempty"`

		VolumesFrom []string `json:"VolumesFrom"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AutoRemove = dataAO1.AutoRemove

	m.Binds = dataAO1.Binds

	m.CapAdd = dataAO1.CapAdd

	m.CapDrop = dataAO1.CapDrop

	m.Capabilities = dataAO1.Capabilities

	m.Cgroup = dataAO1.Cgroup

	m.ConsoleSize = dataAO1.ConsoleSize

	m.ContainerIDFile = dataAO1.ContainerIDFile

	m.DNS = dataAO1.DNS

	m.DNSOptions = dataAO1.DNSOptions

	m.DNSSearch = dataAO1.DNSSearch

	m.ExtraHosts = dataAO1.ExtraHosts

	m.GroupAdd = dataAO1.GroupAdd

	m.IpcMode = dataAO1.IpcMode

	m.Isolation = dataAO1.Isolation

	m.Links = dataAO1.Links

	m.LogConfig = dataAO1.LogConfig

	m.MaskedPaths = dataAO1.MaskedPaths

	m.Mounts = dataAO1.Mounts

	m.NetworkMode = dataAO1.NetworkMode

	m.OomScoreAdj = dataAO1.OomScoreAdj

	m.PidMode = dataAO1.PidMode

	m.PortBindings = dataAO1.PortBindings

	m.Privileged = dataAO1.Privileged

	m.PublishAllPorts = dataAO1.PublishAllPorts

	m.ReadonlyPaths = dataAO1.ReadonlyPaths

	m.ReadonlyRootfs = dataAO1.ReadonlyRootfs

	m.RestartPolicy = dataAO1.RestartPolicy

	m.Runtime = dataAO1.Runtime

	m.SecurityOpt = dataAO1.SecurityOpt

	m.ShmSize = dataAO1.ShmSize

	m.StorageOpt = dataAO1.StorageOpt

	m.Sysctls = dataAO1.Sysctls

	m.Tmpfs = dataAO1.Tmpfs

	m.UTSMode = dataAO1.UTSMode

	m.UsernsMode = dataAO1.UsernsMode

	m.VolumeDriver = dataAO1.VolumeDriver

	m.VolumesFrom = dataAO1.VolumesFrom

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m HostConfig) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.Resources)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		AutoRemove bool `json:"AutoRemove,omitempty"`

		Binds []string `json:"Binds"`

		CapAdd []string `json:"CapAdd"`

		CapDrop []string `json:"CapDrop"`

		Capabilities []string `json:"Capabilities"`

		Cgroup string `json:"Cgroup,omitempty"`

		ConsoleSize []*int64 `json:"ConsoleSize"`

		ContainerIDFile string `json:"ContainerIDFile,omitempty"`

		DNS []string `json:"Dns"`

		DNSOptions []string `json:"DnsOptions"`

		DNSSearch []string `json:"DnsSearch"`

		ExtraHosts []string `json:"ExtraHosts"`

		GroupAdd []string `json:"GroupAdd"`

		IpcMode string `json:"IpcMode,omitempty"`

		Isolation string `json:"Isolation,omitempty"`

		Links []string `json:"Links"`

		LogConfig *HostConfigAO1LogConfig `json:"LogConfig,omitempty"`

		MaskedPaths []string `json:"MaskedPaths"`

		Mounts []*Mount `json:"Mounts"`

		NetworkMode string `json:"NetworkMode,omitempty"`

		OomScoreAdj int64 `json:"OomScoreAdj,omitempty"`

		PidMode string `json:"PidMode,omitempty"`

		PortBindings PortMap `json:"PortBindings,omitempty"`

		Privileged bool `json:"Privileged,omitempty"`

		PublishAllPorts bool `json:"PublishAllPorts,omitempty"`

		ReadonlyPaths []string `json:"ReadonlyPaths"`

		ReadonlyRootfs bool `json:"ReadonlyRootfs,omitempty"`

		RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`

		Runtime string `json:"Runtime,omitempty"`

		SecurityOpt []string `json:"SecurityOpt"`

		ShmSize *int64 `json:"ShmSize,omitempty"`

		StorageOpt map[string]string `json:"StorageOpt,omitempty"`

		Sysctls map[string]string `json:"Sysctls,omitempty"`

		Tmpfs map[string]string `json:"Tmpfs,omitempty"`

		UTSMode string `json:"UTSMode,omitempty"`

		UsernsMode string `json:"UsernsMode,omitempty"`

		VolumeDriver string `json:"VolumeDriver,omitempty"`

		VolumesFrom []string `json:"VolumesFrom"`
	}

	dataAO1.AutoRemove = m.AutoRemove

	dataAO1.Binds = m.Binds

	dataAO1.CapAdd = m.CapAdd

	dataAO1.CapDrop = m.CapDrop

	dataAO1.Capabilities = m.Capabilities

	dataAO1.Cgroup = m.Cgroup

	dataAO1.ConsoleSize = m.ConsoleSize

	dataAO1.ContainerIDFile = m.ContainerIDFile

	dataAO1.DNS = m.DNS

	dataAO1.DNSOptions = m.DNSOptions

	dataAO1.DNSSearch = m.DNSSearch

	dataAO1.ExtraHosts = m.ExtraHosts

	dataAO1.GroupAdd = m.GroupAdd

	dataAO1.IpcMode = m.IpcMode

	dataAO1.Isolation = m.Isolation

	dataAO1.Links = m.Links

	dataAO1.LogConfig = m.LogConfig

	dataAO1.MaskedPaths = m.MaskedPaths

	dataAO1.Mounts = m.Mounts

	dataAO1.NetworkMode = m.NetworkMode

	dataAO1.OomScoreAdj = m.OomScoreAdj

	dataAO1.PidMode = m.PidMode

	dataAO1.PortBindings = m.PortBindings

	dataAO1.Privileged = m.Privileged

	dataAO1.PublishAllPorts = m.PublishAllPorts

	dataAO1.ReadonlyPaths = m.ReadonlyPaths

	dataAO1.ReadonlyRootfs = m.ReadonlyRootfs

	dataAO1.RestartPolicy = m.RestartPolicy

	dataAO1.Runtime = m.Runtime

	dataAO1.SecurityOpt = m.SecurityOpt

	dataAO1.ShmSize = m.ShmSize

	dataAO1.StorageOpt = m.StorageOpt

	dataAO1.Sysctls = m.Sysctls

	dataAO1.Tmpfs = m.Tmpfs

	dataAO1.UTSMode = m.UTSMode

	dataAO1.UsernsMode = m.UsernsMode

	dataAO1.VolumeDriver = m.VolumeDriver

	dataAO1.VolumesFrom = m.VolumesFrom

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this host config
func (m *HostConfig) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with Resources
	if err := m.Resources.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsoleSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsolation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortBindings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestartPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShmSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HostConfig) validateConsoleSize(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsoleSize) { // not required
		return nil
	}

	iConsoleSizeSize := int64(len(m.ConsoleSize))

	if err := validate.MinItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {
		return err
	}

	if err := validate.MaxItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {
		return err
	}

	for i := 0; i < len(m.ConsoleSize); i++ {
		if swag.IsZero(m.ConsoleSize[i]) { // not required
			continue
		}

		if err := validate.MinimumInt("ConsoleSize"+"."+strconv.Itoa(i), "body", int64(*m.ConsoleSize[i]), 0, false); err != nil {
			return err
		}

	}

	return nil
}

var hostConfigTypeIsolationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","process","hyperv"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hostConfigTypeIsolationPropEnum = append(hostConfigTypeIsolationPropEnum, v)
	}
}

// property enum
func (m *HostConfig) validateIsolationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, hostConfigTypeIsolationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *HostConfig) validateIsolation(formats strfmt.Registry) error {

	if swag.IsZero(m.Isolation) { // not required
		return nil
	}

	// value enum
	if err := m.validateIsolationEnum("Isolation", "body", m.Isolation); err != nil {
		return err
	}

	return nil
}

func (m *HostConfig) validateLogConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.LogConfig) { // not required
		return nil
	}

	if m.LogConfig != nil {
		if err := m.LogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("LogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *HostConfig) validateMounts(formats strfmt.Registry) error {

	if swag.IsZero(m.Mounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Mounts); i++ {
		if swag.IsZero(m.Mounts[i]) { // not required
			continue
		}

		if m.Mounts[i] != nil {
			if err := m.Mounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Mounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HostConfig) validatePortBindings(formats strfmt.Registry) error {

	if swag.IsZero(m.PortBindings) { // not required
		return nil
	}

	if err := m.PortBindings.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("PortBindings")
		}
		return err
	}

	return nil
}

func (m *HostConfig) validateRestartPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RestartPolicy) { // not required
		return nil
	}

	if m.RestartPolicy != nil {
		if err := m.RestartPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RestartPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *HostConfig) validateShmSize(formats strfmt.Registry) error {

	if swag.IsZero(m.ShmSize) { // not required
		return nil
	}

	if err := validate.MinimumInt("ShmSize", "body", int64(*m.ShmSize), 0, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *HostConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HostConfig) UnmarshalBinary(b []byte) error {
	var res HostConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HostConfigAO1LogConfig The logging configuration for this container
// swagger:model HostConfigAO1LogConfig
type HostConfigAO1LogConfig struct {

	// config
	Config map[string]string `json:"Config,omitempty"`

	// type
	// Enum: [json-file syslog journald gelf fluentd awslogs splunk etwlogs none]
	Type string `json:"Type,omitempty"`
}

// Validate validates this host config a o1 log config
func (m *HostConfigAO1LogConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var hostConfigAO1LogConfigTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["json-file","syslog","journald","gelf","fluentd","awslogs","splunk","etwlogs","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hostConfigAO1LogConfigTypeTypePropEnum = append(hostConfigAO1LogConfigTypeTypePropEnum, v)
	}
}

const (

	// HostConfigAO1LogConfigTypeJSONFile captures enum value "json-file"
	HostConfigAO1LogConfigTypeJSONFile string = "json-file"

	// HostConfigAO1LogConfigTypeSyslog captures enum value "syslog"
	HostConfigAO1LogConfigTypeSyslog string = "syslog"

	// HostConfigAO1LogConfigTypeJournald captures enum value "journald"
	HostConfigAO1LogConfigTypeJournald string = "journald"

	// HostConfigAO1LogConfigTypeGelf captures enum value "gelf"
	HostConfigAO1LogConfigTypeGelf string = "gelf"

	// HostConfigAO1LogConfigTypeFluentd captures enum value "fluentd"
	HostConfigAO1LogConfigTypeFluentd string = "fluentd"

	// HostConfigAO1LogConfigTypeAwslogs captures enum value "awslogs"
	HostConfigAO1LogConfigTypeAwslogs string = "awslogs"

	// HostConfigAO1LogConfigTypeSplunk captures enum value "splunk"
	HostConfigAO1LogConfigTypeSplunk string = "splunk"

	// HostConfigAO1LogConfigTypeEtwlogs captures enum value "etwlogs"
	HostConfigAO1LogConfigTypeEtwlogs string = "etwlogs"

	// HostConfigAO1LogConfigTypeNone captures enum value "none"
	HostConfigAO1LogConfigTypeNone string = "none"
)

// prop value enum
func (m *HostConfigAO1LogConfig) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, hostConfigAO1LogConfigTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *HostConfigAO1LogConfig) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("LogConfig"+"."+"Type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *HostConfigAO1LogConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HostConfigAO1LogConfig) UnmarshalBinary(b []byte) error {
	var res HostConfigAO1LogConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
