// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TaskSpec User modifiable task configuration.
// swagger:model TaskSpec
type TaskSpec struct {

	// container spec
	ContainerSpec *TaskSpecContainerSpec `json:"ContainerSpec,omitempty"`

	// A counter that triggers an update even if no relevant parameters have been changed.
	ForceUpdate int64 `json:"ForceUpdate,omitempty"`

	// log driver
	LogDriver *TaskSpecLogDriver `json:"LogDriver,omitempty"`

	// network attachment spec
	NetworkAttachmentSpec *TaskSpecNetworkAttachmentSpec `json:"NetworkAttachmentSpec,omitempty"`

	// networks
	Networks []*TaskSpecNetworksItems0 `json:"Networks"`

	// placement
	Placement *TaskSpecPlacement `json:"Placement,omitempty"`

	// plugin spec
	PluginSpec *TaskSpecPluginSpec `json:"PluginSpec,omitempty"`

	// resources
	Resources *TaskSpecResources `json:"Resources,omitempty"`

	// restart policy
	RestartPolicy *TaskSpecRestartPolicy `json:"RestartPolicy,omitempty"`

	// Runtime is the type of runtime specified for the task executor.
	Runtime string `json:"Runtime,omitempty"`
}

// Validate validates this task spec
func (m *TaskSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContainerSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogDriver(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkAttachmentSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlacement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePluginSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestartPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpec) validateContainerSpec(formats strfmt.Registry) error {

	if swag.IsZero(m.ContainerSpec) { // not required
		return nil
	}

	if m.ContainerSpec != nil {
		if err := m.ContainerSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ContainerSpec")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpec) validateLogDriver(formats strfmt.Registry) error {

	if swag.IsZero(m.LogDriver) { // not required
		return nil
	}

	if m.LogDriver != nil {
		if err := m.LogDriver.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("LogDriver")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpec) validateNetworkAttachmentSpec(formats strfmt.Registry) error {

	if swag.IsZero(m.NetworkAttachmentSpec) { // not required
		return nil
	}

	if m.NetworkAttachmentSpec != nil {
		if err := m.NetworkAttachmentSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("NetworkAttachmentSpec")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpec) validateNetworks(formats strfmt.Registry) error {

	if swag.IsZero(m.Networks) { // not required
		return nil
	}

	for i := 0; i < len(m.Networks); i++ {
		if swag.IsZero(m.Networks[i]) { // not required
			continue
		}

		if m.Networks[i] != nil {
			if err := m.Networks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Networks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TaskSpec) validatePlacement(formats strfmt.Registry) error {

	if swag.IsZero(m.Placement) { // not required
		return nil
	}

	if m.Placement != nil {
		if err := m.Placement.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Placement")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpec) validatePluginSpec(formats strfmt.Registry) error {

	if swag.IsZero(m.PluginSpec) { // not required
		return nil
	}

	if m.PluginSpec != nil {
		if err := m.PluginSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("PluginSpec")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpec) validateResources(formats strfmt.Registry) error {

	if swag.IsZero(m.Resources) { // not required
		return nil
	}

	if m.Resources != nil {
		if err := m.Resources.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Resources")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpec) validateRestartPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RestartPolicy) { // not required
		return nil
	}

	if m.RestartPolicy != nil {
		if err := m.RestartPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RestartPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpec) UnmarshalBinary(b []byte) error {
	var res TaskSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpec Container spec for the service.
//
// <p><br /></p>
//
// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
// > mutually exclusive. PluginSpec is only used when the Runtime field
// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
// > field is set to `attachment`.
//
// swagger:model TaskSpecContainerSpec
type TaskSpecContainerSpec struct {

	// Arguments to the command.
	Args []string `json:"Args"`

	// The command to be run in the image.
	Command []string `json:"Command"`

	// Configs contains references to zero or more configs that will be exposed to the service.
	Configs []*TaskSpecContainerSpecConfigsItems0 `json:"Configs"`

	// DNS config
	DNSConfig *TaskSpecContainerSpecDNSConfig `json:"DNSConfig,omitempty"`

	// The working directory for commands to run in.
	Dir string `json:"Dir,omitempty"`

	// A list of environment variables in the form `VAR=value`.
	Env []string `json:"Env"`

	// A list of additional groups that the container process will run as.
	Groups []string `json:"Groups"`

	// health check
	HealthCheck *HealthConfig `json:"HealthCheck,omitempty"`

	// The hostname to use for the container, as a valid RFC 1123 hostname.
	Hostname string `json:"Hostname,omitempty"`

	// A list of hostname/IP mappings to add to the container's `hosts`
	// file. The format of extra hosts is specified in the
	// [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html)
	// man page:
	//
	//     IP_address canonical_hostname [aliases...]
	//
	Hosts []string `json:"Hosts"`

	// The image name to use for the container
	Image string `json:"Image,omitempty"`

	// Run an init inside the container that forwards signals and reaps processes. This field is omitted if empty, and the default (as configured on the daemon) is used.
	Init *bool `json:"Init,omitempty"`

	// Isolation technology of the containers running the service. (Windows only)
	// Enum: [default process hyperv]
	Isolation string `json:"Isolation,omitempty"`

	// User-defined key/value data.
	Labels map[string]string `json:"Labels,omitempty"`

	// Specification for mounts to be added to containers created as part of the service.
	Mounts []*Mount `json:"Mounts"`

	// Open `stdin`
	OpenStdin bool `json:"OpenStdin,omitempty"`

	// privileges
	Privileges *TaskSpecContainerSpecPrivileges `json:"Privileges,omitempty"`

	// Mount the container's root filesystem as read only.
	ReadOnly bool `json:"ReadOnly,omitempty"`

	// Secrets contains references to zero or more secrets that will be exposed to the service.
	Secrets []*TaskSpecContainerSpecSecretsItems0 `json:"Secrets"`

	// Amount of time to wait for the container to terminate before forcefully killing it.
	StopGracePeriod int64 `json:"StopGracePeriod,omitempty"`

	// Signal to stop the container.
	StopSignal string `json:"StopSignal,omitempty"`

	// Set kernel namedspaced parameters (sysctls) in the container.
	// The Sysctls option on services accepts the same sysctls as the
	// are supported on containers. Note that while the same sysctls are
	// supported, no guarantees or checks are made about their
	// suitability for a clustered environment, and it's up to the user
	// to determine whether a given sysctl will work properly in a
	// Service.
	//
	Sysctls map[string]string `json:"Sysctls,omitempty"`

	// Whether a pseudo-TTY should be allocated.
	TTY bool `json:"TTY,omitempty"`

	// The user inside the container.
	User string `json:"User,omitempty"`
}

// Validate validates this task spec container spec
func (m *TaskSpecContainerSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConfigs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHealthCheck(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsolation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivileges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecrets(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecContainerSpec) validateConfigs(formats strfmt.Registry) error {

	if swag.IsZero(m.Configs) { // not required
		return nil
	}

	for i := 0; i < len(m.Configs); i++ {
		if swag.IsZero(m.Configs[i]) { // not required
			continue
		}

		if m.Configs[i] != nil {
			if err := m.Configs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ContainerSpec" + "." + "Configs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TaskSpecContainerSpec) validateDNSConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSConfig) { // not required
		return nil
	}

	if m.DNSConfig != nil {
		if err := m.DNSConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ContainerSpec" + "." + "DNSConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpecContainerSpec) validateHealthCheck(formats strfmt.Registry) error {

	if swag.IsZero(m.HealthCheck) { // not required
		return nil
	}

	if m.HealthCheck != nil {
		if err := m.HealthCheck.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ContainerSpec" + "." + "HealthCheck")
			}
			return err
		}
	}

	return nil
}

var taskSpecContainerSpecTypeIsolationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","process","hyperv"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taskSpecContainerSpecTypeIsolationPropEnum = append(taskSpecContainerSpecTypeIsolationPropEnum, v)
	}
}

const (

	// TaskSpecContainerSpecIsolationDefault captures enum value "default"
	TaskSpecContainerSpecIsolationDefault string = "default"

	// TaskSpecContainerSpecIsolationProcess captures enum value "process"
	TaskSpecContainerSpecIsolationProcess string = "process"

	// TaskSpecContainerSpecIsolationHyperv captures enum value "hyperv"
	TaskSpecContainerSpecIsolationHyperv string = "hyperv"
)

// prop value enum
func (m *TaskSpecContainerSpec) validateIsolationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, taskSpecContainerSpecTypeIsolationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TaskSpecContainerSpec) validateIsolation(formats strfmt.Registry) error {

	if swag.IsZero(m.Isolation) { // not required
		return nil
	}

	// value enum
	if err := m.validateIsolationEnum("ContainerSpec"+"."+"Isolation", "body", m.Isolation); err != nil {
		return err
	}

	return nil
}

func (m *TaskSpecContainerSpec) validateMounts(formats strfmt.Registry) error {

	if swag.IsZero(m.Mounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Mounts); i++ {
		if swag.IsZero(m.Mounts[i]) { // not required
			continue
		}

		if m.Mounts[i] != nil {
			if err := m.Mounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ContainerSpec" + "." + "Mounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TaskSpecContainerSpec) validatePrivileges(formats strfmt.Registry) error {

	if swag.IsZero(m.Privileges) { // not required
		return nil
	}

	if m.Privileges != nil {
		if err := m.Privileges.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ContainerSpec" + "." + "Privileges")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpecContainerSpec) validateSecrets(formats strfmt.Registry) error {

	if swag.IsZero(m.Secrets) { // not required
		return nil
	}

	for i := 0; i < len(m.Secrets); i++ {
		if swag.IsZero(m.Secrets[i]) { // not required
			continue
		}

		if m.Secrets[i] != nil {
			if err := m.Secrets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ContainerSpec" + "." + "Secrets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpec) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecConfigsItems0 task spec container spec configs items0
// swagger:model TaskSpecContainerSpecConfigsItems0
type TaskSpecContainerSpecConfigsItems0 struct {

	// ConfigID represents the ID of the specific config that we're referencing.
	ConfigID string `json:"ConfigID,omitempty"`

	// ConfigName is the name of the config that this references, but this is just provided for
	// lookup/display purposes. The config in the reference will be identified by its ID.
	//
	ConfigName string `json:"ConfigName,omitempty"`

	// file
	File *TaskSpecContainerSpecConfigsItems0File `json:"File,omitempty"`

	// Runtime represents a target that is not mounted into the container but is used by the task
	//
	// <p><br /><p>
	//
	// > **Note**: `Configs.File` and `Configs.Runtime` are mutually exclusive
	//
	Runtime interface{} `json:"Runtime,omitempty"`
}

// Validate validates this task spec container spec configs items0
func (m *TaskSpecContainerSpecConfigsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecContainerSpecConfigsItems0) validateFile(formats strfmt.Registry) error {

	if swag.IsZero(m.File) { // not required
		return nil
	}

	if m.File != nil {
		if err := m.File.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("File")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecConfigsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecConfigsItems0) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecConfigsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecConfigsItems0File File represents a specific target that is backed by a file.
//
// <p><br /><p>
//
// > **Note**: `Configs.File` and `Configs.Runtime` are mutually exclusive
//
// swagger:model TaskSpecContainerSpecConfigsItems0File
type TaskSpecContainerSpecConfigsItems0File struct {

	// GID represents the file GID.
	GID string `json:"GID,omitempty"`

	// Mode represents the FileMode of the file.
	Mode uint32 `json:"Mode,omitempty"`

	// Name represents the final filename in the filesystem.
	Name string `json:"Name,omitempty"`

	// UID represents the file UID.
	UID string `json:"UID,omitempty"`
}

// Validate validates this task spec container spec configs items0 file
func (m *TaskSpecContainerSpecConfigsItems0File) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecConfigsItems0File) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecConfigsItems0File) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecConfigsItems0File
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecDNSConfig Specification for DNS related configurations in resolver configuration file (`resolv.conf`).
// swagger:model TaskSpecContainerSpecDNSConfig
type TaskSpecContainerSpecDNSConfig struct {

	// The IP addresses of the name servers.
	Nameservers []string `json:"Nameservers"`

	// A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.).
	Options []string `json:"Options"`

	// A search list for host-name lookup.
	Search []string `json:"Search"`
}

// Validate validates this task spec container spec DNS config
func (m *TaskSpecContainerSpecDNSConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecDNSConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecDNSConfig) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecDNSConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecPrivileges Security options for the container
// swagger:model TaskSpecContainerSpecPrivileges
type TaskSpecContainerSpecPrivileges struct {

	// credential spec
	CredentialSpec *TaskSpecContainerSpecPrivilegesCredentialSpec `json:"CredentialSpec,omitempty"`

	// s e linux context
	SELinuxContext *TaskSpecContainerSpecPrivilegesSELinuxContext `json:"SELinuxContext,omitempty"`
}

// Validate validates this task spec container spec privileges
func (m *TaskSpecContainerSpecPrivileges) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCredentialSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSELinuxContext(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecContainerSpecPrivileges) validateCredentialSpec(formats strfmt.Registry) error {

	if swag.IsZero(m.CredentialSpec) { // not required
		return nil
	}

	if m.CredentialSpec != nil {
		if err := m.CredentialSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ContainerSpec" + "." + "Privileges" + "." + "CredentialSpec")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpecContainerSpecPrivileges) validateSELinuxContext(formats strfmt.Registry) error {

	if swag.IsZero(m.SELinuxContext) { // not required
		return nil
	}

	if m.SELinuxContext != nil {
		if err := m.SELinuxContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ContainerSpec" + "." + "Privileges" + "." + "SELinuxContext")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecPrivileges) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecPrivileges) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecPrivileges
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecPrivilegesCredentialSpec CredentialSpec for managed service account (Windows only)
// swagger:model TaskSpecContainerSpecPrivilegesCredentialSpec
type TaskSpecContainerSpecPrivilegesCredentialSpec struct {

	// Load credential spec from a Swarm Config with the given ID.
	// The specified config must also be present in the Configs field with the Runtime property set.
	//
	// <p><br /></p>
	//
	//
	// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`, and `CredentialSpec.Config` are mutually exclusive.
	//
	Config string `json:"Config,omitempty"`

	// Load credential spec from this file. The file is read by the daemon, and must be present in the
	// `CredentialSpecs` subdirectory in the docker data directory, which defaults to
	// `C:\ProgramData\Docker\` on Windows.
	//
	// For example, specifying `spec.json` loads `C:\ProgramData\Docker\CredentialSpecs\spec.json`.
	//
	// <p><br /></p>
	//
	// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`, and `CredentialSpec.Config` are mutually exclusive.
	//
	File string `json:"File,omitempty"`

	// Load credential spec from this value in the Windows registry. The specified registry value must be
	// located in:
	//
	// `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs`
	//
	// <p><br /></p>
	//
	//
	// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`, and `CredentialSpec.Config` are mutually exclusive.
	//
	Registry string `json:"Registry,omitempty"`
}

// Validate validates this task spec container spec privileges credential spec
func (m *TaskSpecContainerSpecPrivilegesCredentialSpec) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecPrivilegesCredentialSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecPrivilegesCredentialSpec) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecPrivilegesCredentialSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecPrivilegesSELinuxContext SELinux labels of the container
// swagger:model TaskSpecContainerSpecPrivilegesSELinuxContext
type TaskSpecContainerSpecPrivilegesSELinuxContext struct {

	// Disable SELinux
	Disable bool `json:"Disable,omitempty"`

	// SELinux level label
	Level string `json:"Level,omitempty"`

	// SELinux role label
	Role string `json:"Role,omitempty"`

	// SELinux type label
	Type string `json:"Type,omitempty"`

	// SELinux user label
	User string `json:"User,omitempty"`
}

// Validate validates this task spec container spec privileges s e linux context
func (m *TaskSpecContainerSpecPrivilegesSELinuxContext) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecPrivilegesSELinuxContext) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecPrivilegesSELinuxContext) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecPrivilegesSELinuxContext
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecSecretsItems0 task spec container spec secrets items0
// swagger:model TaskSpecContainerSpecSecretsItems0
type TaskSpecContainerSpecSecretsItems0 struct {

	// file
	File *TaskSpecContainerSpecSecretsItems0File `json:"File,omitempty"`

	// SecretID represents the ID of the specific secret that we're referencing.
	SecretID string `json:"SecretID,omitempty"`

	// SecretName is the name of the secret that this references, but this is just provided for
	// lookup/display purposes. The secret in the reference will be identified by its ID.
	//
	SecretName string `json:"SecretName,omitempty"`
}

// Validate validates this task spec container spec secrets items0
func (m *TaskSpecContainerSpecSecretsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecContainerSpecSecretsItems0) validateFile(formats strfmt.Registry) error {

	if swag.IsZero(m.File) { // not required
		return nil
	}

	if m.File != nil {
		if err := m.File.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("File")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecSecretsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecSecretsItems0) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecSecretsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecContainerSpecSecretsItems0File File represents a specific target that is backed by a file.
// swagger:model TaskSpecContainerSpecSecretsItems0File
type TaskSpecContainerSpecSecretsItems0File struct {

	// GID represents the file GID.
	GID string `json:"GID,omitempty"`

	// Mode represents the FileMode of the file.
	Mode uint32 `json:"Mode,omitempty"`

	// Name represents the final filename in the filesystem.
	Name string `json:"Name,omitempty"`

	// UID represents the file UID.
	UID string `json:"UID,omitempty"`
}

// Validate validates this task spec container spec secrets items0 file
func (m *TaskSpecContainerSpecSecretsItems0File) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecContainerSpecSecretsItems0File) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecContainerSpecSecretsItems0File) UnmarshalBinary(b []byte) error {
	var res TaskSpecContainerSpecSecretsItems0File
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecLogDriver Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
// swagger:model TaskSpecLogDriver
type TaskSpecLogDriver struct {

	// name
	Name string `json:"Name,omitempty"`

	// options
	Options map[string]string `json:"Options,omitempty"`
}

// Validate validates this task spec log driver
func (m *TaskSpecLogDriver) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecLogDriver) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecLogDriver) UnmarshalBinary(b []byte) error {
	var res TaskSpecLogDriver
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecNetworkAttachmentSpec Read-only spec type for non-swarm containers attached to swarm overlay
// networks.
//
// <p><br /></p>
//
// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
// > mutually exclusive. PluginSpec is only used when the Runtime field
// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
// > field is set to `attachment`.
//
// swagger:model TaskSpecNetworkAttachmentSpec
type TaskSpecNetworkAttachmentSpec struct {

	// ID of the container represented by this task
	ContainerID string `json:"ContainerID,omitempty"`
}

// Validate validates this task spec network attachment spec
func (m *TaskSpecNetworkAttachmentSpec) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecNetworkAttachmentSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecNetworkAttachmentSpec) UnmarshalBinary(b []byte) error {
	var res TaskSpecNetworkAttachmentSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecNetworksItems0 task spec networks items0
// swagger:model TaskSpecNetworksItems0
type TaskSpecNetworksItems0 struct {

	// aliases
	Aliases []string `json:"Aliases"`

	// target
	Target string `json:"Target,omitempty"`
}

// Validate validates this task spec networks items0
func (m *TaskSpecNetworksItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecNetworksItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecNetworksItems0) UnmarshalBinary(b []byte) error {
	var res TaskSpecNetworksItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecPlacement task spec placement
// swagger:model TaskSpecPlacement
type TaskSpecPlacement struct {

	// An array of constraints.
	Constraints []string `json:"Constraints"`

	// Maximum number of replicas for per node (default value is 0, which is unlimited)
	MaxReplicas int64 `json:"MaxReplicas,omitempty"`

	// Platforms stores all the platforms that the service's image can
	// run on. This field is used in the platform filter for scheduling.
	// If empty, then the platform filter is off, meaning there are no
	// scheduling restrictions.
	//
	Platforms []*Platform `json:"Platforms"`

	// Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence.
	Preferences []*TaskSpecPlacementPreferencesItems0 `json:"Preferences"`
}

// Validate validates this task spec placement
func (m *TaskSpecPlacement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlatforms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreferences(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecPlacement) validatePlatforms(formats strfmt.Registry) error {

	if swag.IsZero(m.Platforms) { // not required
		return nil
	}

	for i := 0; i < len(m.Platforms); i++ {
		if swag.IsZero(m.Platforms[i]) { // not required
			continue
		}

		if m.Platforms[i] != nil {
			if err := m.Platforms[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Placement" + "." + "Platforms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TaskSpecPlacement) validatePreferences(formats strfmt.Registry) error {

	if swag.IsZero(m.Preferences) { // not required
		return nil
	}

	for i := 0; i < len(m.Preferences); i++ {
		if swag.IsZero(m.Preferences[i]) { // not required
			continue
		}

		if m.Preferences[i] != nil {
			if err := m.Preferences[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Placement" + "." + "Preferences" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecPlacement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecPlacement) UnmarshalBinary(b []byte) error {
	var res TaskSpecPlacement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecPlacementPreferencesItems0 task spec placement preferences items0
// swagger:model TaskSpecPlacementPreferencesItems0
type TaskSpecPlacementPreferencesItems0 struct {

	// spread
	Spread *TaskSpecPlacementPreferencesItems0Spread `json:"Spread,omitempty"`
}

// Validate validates this task spec placement preferences items0
func (m *TaskSpecPlacementPreferencesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSpread(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecPlacementPreferencesItems0) validateSpread(formats strfmt.Registry) error {

	if swag.IsZero(m.Spread) { // not required
		return nil
	}

	if m.Spread != nil {
		if err := m.Spread.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Spread")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecPlacementPreferencesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecPlacementPreferencesItems0) UnmarshalBinary(b []byte) error {
	var res TaskSpecPlacementPreferencesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecPlacementPreferencesItems0Spread task spec placement preferences items0 spread
// swagger:model TaskSpecPlacementPreferencesItems0Spread
type TaskSpecPlacementPreferencesItems0Spread struct {

	// label descriptor, such as engine.labels.az
	SpreadDescriptor string `json:"SpreadDescriptor,omitempty"`
}

// Validate validates this task spec placement preferences items0 spread
func (m *TaskSpecPlacementPreferencesItems0Spread) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecPlacementPreferencesItems0Spread) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecPlacementPreferencesItems0Spread) UnmarshalBinary(b []byte) error {
	var res TaskSpecPlacementPreferencesItems0Spread
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecPluginSpec Plugin spec for the service.  *(Experimental release only.)*
//
// <p><br /></p>
//
// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
// > mutually exclusive. PluginSpec is only used when the Runtime field
// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
// > field is set to `attachment`.
//
// swagger:model TaskSpecPluginSpec
type TaskSpecPluginSpec struct {

	// Disable the plugin once scheduled.
	Disabled bool `json:"Disabled,omitempty"`

	// The name or 'alias' to use for the plugin.
	Name string `json:"Name,omitempty"`

	// plugin privilege
	PluginPrivilege []*TaskSpecPluginSpecPluginPrivilegeItems0 `json:"PluginPrivilege"`

	// The plugin image reference to use.
	Remote string `json:"Remote,omitempty"`
}

// Validate validates this task spec plugin spec
func (m *TaskSpecPluginSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePluginPrivilege(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecPluginSpec) validatePluginPrivilege(formats strfmt.Registry) error {

	if swag.IsZero(m.PluginPrivilege) { // not required
		return nil
	}

	for i := 0; i < len(m.PluginPrivilege); i++ {
		if swag.IsZero(m.PluginPrivilege[i]) { // not required
			continue
		}

		if m.PluginPrivilege[i] != nil {
			if err := m.PluginPrivilege[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("PluginSpec" + "." + "PluginPrivilege" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecPluginSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecPluginSpec) UnmarshalBinary(b []byte) error {
	var res TaskSpecPluginSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecPluginSpecPluginPrivilegeItems0 Describes a permission accepted by the user upon installing the plugin.
// swagger:model TaskSpecPluginSpecPluginPrivilegeItems0
type TaskSpecPluginSpecPluginPrivilegeItems0 struct {

	// description
	Description string `json:"Description,omitempty"`

	// name
	Name string `json:"Name,omitempty"`

	// value
	Value []string `json:"Value"`
}

// Validate validates this task spec plugin spec plugin privilege items0
func (m *TaskSpecPluginSpecPluginPrivilegeItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecPluginSpecPluginPrivilegeItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecPluginSpecPluginPrivilegeItems0) UnmarshalBinary(b []byte) error {
	var res TaskSpecPluginSpecPluginPrivilegeItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecResources Resource requirements which apply to each individual container created as part of the service.
// swagger:model TaskSpecResources
type TaskSpecResources struct {

	// Define resources limits.
	Limits *ResourceObject `json:"Limits,omitempty"`

	// Define resources reservation.
	Reservation *ResourceObject `json:"Reservation,omitempty"`
}

// Validate validates this task spec resources
func (m *TaskSpecResources) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLimits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReservation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskSpecResources) validateLimits(formats strfmt.Registry) error {

	if swag.IsZero(m.Limits) { // not required
		return nil
	}

	if m.Limits != nil {
		if err := m.Limits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Resources" + "." + "Limits")
			}
			return err
		}
	}

	return nil
}

func (m *TaskSpecResources) validateReservation(formats strfmt.Registry) error {

	if swag.IsZero(m.Reservation) { // not required
		return nil
	}

	if m.Reservation != nil {
		if err := m.Reservation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Resources" + "." + "Reservation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecResources) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecResources) UnmarshalBinary(b []byte) error {
	var res TaskSpecResources
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TaskSpecRestartPolicy Specification for the restart policy which applies to containers created as part of this service.
// swagger:model TaskSpecRestartPolicy
type TaskSpecRestartPolicy struct {

	// Condition for restart.
	// Enum: [none on-failure any]
	Condition string `json:"Condition,omitempty"`

	// Delay between restart attempts.
	Delay int64 `json:"Delay,omitempty"`

	// Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).
	MaxAttempts int64 `json:"MaxAttempts,omitempty"`

	// Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).
	Window int64 `json:"Window,omitempty"`
}

// Validate validates this task spec restart policy
func (m *TaskSpecRestartPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var taskSpecRestartPolicyTypeConditionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","on-failure","any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taskSpecRestartPolicyTypeConditionPropEnum = append(taskSpecRestartPolicyTypeConditionPropEnum, v)
	}
}

const (

	// TaskSpecRestartPolicyConditionNone captures enum value "none"
	TaskSpecRestartPolicyConditionNone string = "none"

	// TaskSpecRestartPolicyConditionOnFailure captures enum value "on-failure"
	TaskSpecRestartPolicyConditionOnFailure string = "on-failure"

	// TaskSpecRestartPolicyConditionAny captures enum value "any"
	TaskSpecRestartPolicyConditionAny string = "any"
)

// prop value enum
func (m *TaskSpecRestartPolicy) validateConditionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, taskSpecRestartPolicyTypeConditionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TaskSpecRestartPolicy) validateCondition(formats strfmt.Registry) error {

	if swag.IsZero(m.Condition) { // not required
		return nil
	}

	// value enum
	if err := m.validateConditionEnum("RestartPolicy"+"."+"Condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskSpecRestartPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskSpecRestartPolicy) UnmarshalBinary(b []byte) error {
	var res TaskSpecRestartPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
