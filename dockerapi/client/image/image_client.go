// Code generated by go-swagger; DO NOT EDIT.

package image

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"io"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new image API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for image API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
BuildPrune deletes builder cache
*/
func (a *Client) BuildPrune(params *BuildPruneParams) (*BuildPruneOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildPruneParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "BuildPrune",
		Method:             "POST",
		PathPattern:        "/build/prune",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BuildPruneReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*BuildPruneOK), nil

}

/*
ImageBuild builds an image

Build an image from a tar archive with a `Dockerfile` in it.

The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).

The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.

The build is canceled if the client drops the connection by quitting or being killed.

*/
func (a *Client) ImageBuild(params *ImageBuildParams) (*ImageBuildOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageBuildParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageBuild",
		Method:             "POST",
		PathPattern:        "/build",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageBuildReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageBuildOK), nil

}

/*
ImageCommit creates a new image from a container
*/
func (a *Client) ImageCommit(params *ImageCommitParams) (*ImageCommitCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageCommitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageCommit",
		Method:             "POST",
		PathPattern:        "/commit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageCommitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageCommitCreated), nil

}

/*
ImageCreate creates an image

Create an image by either pulling it from a registry or importing it.
*/
func (a *Client) ImageCreate(params *ImageCreateParams) (*ImageCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageCreate",
		Method:             "POST",
		PathPattern:        "/images/create",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/octet-stream", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageCreateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageCreateOK), nil

}

/*
ImageDelete removes an image

Remove an image, along with any untagged parent images that were
referenced by that image.

Images can't be removed if they have descendant images, are being
used by a running container or are being used by a build.

*/
func (a *Client) ImageDelete(params *ImageDeleteParams) (*ImageDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageDelete",
		Method:             "DELETE",
		PathPattern:        "/images/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageDeleteOK), nil

}

/*
ImageGet exports an image

Get a tarball containing all images and metadata for a repository.

If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.

### Image tarball format

An image tarball contains one directory per image layer (named using its long ID), each containing these files:

- `VERSION`: currently `1.0` - the file format version
- `json`: detailed layer information, similar to `docker inspect layer_id`
- `layer.tar`: A tarfile containing the filesystem changes in this layer

The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.

If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.

```json
{
  "hello-world": {
    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
  }
}
```

*/
func (a *Client) ImageGet(params *ImageGetParams, writer io.Writer) (*ImageGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageGet",
		Method:             "GET",
		PathPattern:        "/images/{name}/get",
		ProducesMediaTypes: []string{"application/x-tar"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageGetReader{formats: a.formats, writer: writer},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageGetOK), nil

}

/*
ImageGetAll exports several images

Get a tarball containing all images and metadata for several image repositories.

For each value of the `names` parameter: if it is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned; if it is an image ID, similarly only that image (and its parents) are returned and there would be no names referenced in the 'repositories' file for this image ID.

For details on the format, see [the export image endpoint](#operation/ImageGet).

*/
func (a *Client) ImageGetAll(params *ImageGetAllParams, writer io.Writer) (*ImageGetAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageGetAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageGetAll",
		Method:             "GET",
		PathPattern:        "/images/get",
		ProducesMediaTypes: []string{"application/x-tar"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageGetAllReader{formats: a.formats, writer: writer},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageGetAllOK), nil

}

/*
ImageHistory gets the history of an image

Return parent layers of an image.
*/
func (a *Client) ImageHistory(params *ImageHistoryParams) (*ImageHistoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageHistoryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageHistory",
		Method:             "GET",
		PathPattern:        "/images/{name}/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageHistoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageHistoryOK), nil

}

/*
ImageInspect inspects an image

Return low-level information about an image.
*/
func (a *Client) ImageInspect(params *ImageInspectParams) (*ImageInspectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageInspectParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageInspect",
		Method:             "GET",
		PathPattern:        "/images/{name}/json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageInspectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageInspectOK), nil

}

/*
ImageList lists images

Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
*/
func (a *Client) ImageList(params *ImageListParams) (*ImageListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageList",
		Method:             "GET",
		PathPattern:        "/images/json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageListOK), nil

}

/*
ImageLoad imports images

Load a set of images and tags into a repository.

For details on the format, see [the export image endpoint](#operation/ImageGet).

*/
func (a *Client) ImageLoad(params *ImageLoadParams) (*ImageLoadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageLoadParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageLoad",
		Method:             "POST",
		PathPattern:        "/images/load",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/x-tar"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageLoadReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageLoadOK), nil

}

/*
ImagePrune deletes unused images
*/
func (a *Client) ImagePrune(params *ImagePruneParams) (*ImagePruneOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImagePruneParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImagePrune",
		Method:             "POST",
		PathPattern:        "/images/prune",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImagePruneReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImagePruneOK), nil

}

/*
ImagePush pushes an image

Push an image to a registry.

If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, `registry.example.com/myimage:latest`.

The push is cancelled if the HTTP connection is closed.

*/
func (a *Client) ImagePush(params *ImagePushParams) (*ImagePushOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImagePushParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImagePush",
		Method:             "POST",
		PathPattern:        "/images/{name}/push",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImagePushReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImagePushOK), nil

}

/*
ImageSearch searches images

Search for an image on Docker Hub.
*/
func (a *Client) ImageSearch(params *ImageSearchParams) (*ImageSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageSearch",
		Method:             "GET",
		PathPattern:        "/images/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageSearchReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageSearchOK), nil

}

/*
ImageTag tags an image

Tag an image so that it becomes part of a repository.
*/
func (a *Client) ImageTag(params *ImageTagParams) (*ImageTagCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageTagParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImageTag",
		Method:             "POST",
		PathPattern:        "/images/{name}/tag",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageTagReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImageTagCreated), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
